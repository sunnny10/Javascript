/**
 * 자바스크립트의 특징
 * 
 * 1. 인터프리터 언어
 * - 실행 속도가 느릴 것 같지만 최근 웹 브라우저 대부분에는 실행 시간에 자바스크립트 코드를 컴파일하는 JIT(Just In Time Compiler) 컴파일러가 내장되어 있어 
 * 실행 속도가 매우 빨라졌다.
 * 
 * 2. 동적 프로토타입 기반 객체 지향 언어
 * - C++, Java 등은 클래스를 이용하여 객체를 생성하는 클래스 기반 객체 지향 언어
 * - 반면 자바스크립트는 클래스가 아닌 프로토타입을 상속하는 프로토타입 기반 객체 지향 언어
 * - 따라서 객체를 생성한 후에도 프로퍼티와 메서드를 동적으로 추가하거나 삭제할 수 있다.
 * - 이 또한 클래스 기반 객체 지향 언어의 객체와 다른 점이다.
 * 
 * 3. 동적 타입 언어
 * - C++, Java는 실행되기 전에 변수 타입이 결정되는 정적 타입 언어
 * - 자바스크립트는 변수 타입이 없다.
 * - 따라서 프로그램을 실행하는 도중에 변수에 저장되는 데이터 타입이 동적으로 바뀔 수 있다 -> 동적 타입 언어
 * 
 * 4. 함수가 일급 객체
 * - 자바스크립트의 함수는 객체, 함수에 함수를 인수로 넘길 수 있다.
 * - 이 특성을 활용하면 고차 함수를 구현할 수 있어 함수형 프로그래밍이 가능해진다.
 * 
 * 5. 함수가 클로저를 정의한다.
 * - 자바스크립트의 함수는 클로저를 정의한다.
 * - 클로저로 변수를 은닉하거나 영속성을 보장하는 등 다양한 기능을 구현할 수 있다.
 */

/**
 * 변수
 * - 변수는 값을 담기 위해 이름을 붙인 상자. 
 * - 컴퓨터의 메모리에 일정한 크기의 영역으로 생성된다.
 * 
 * 변수 선언
 * - var
 * - let, const(ES2015+ 문법) : 특징 - 블록 스코프(범위)
 * - 예제 코드
 */

// if(true) {
//     var x = 3;
// }
// console.log(x);

// if(true) {
//     const y = 3;
// }
// console.error(y);
/** 결과는?
 * x는 정상적으로 출력되는데 y는 에러가 발생한다. 
 * var는 함수 스코프를 가지므로 if 문의 블록과 관계없이 접근할 수 있다.
 * 하지만 const와 let은 블록 스코프를 가지므로 블록 밖에서는 변수에 접근할 수 없다. 블록의 범위란 중괄호({ 와 } 사이)이다.
 * 함수 스코프 대신 블록 스코프를 사용함으로써 호이스팅 같은 문제가 해결된다.
 * 
 * 참고) 호이스팅
 *  예제 코드
 * */ 
// console.log(x);
// var x;
/**
 * 이 코드에서 아직 변수 x가 선언되지 않았기 때문에 오류가 발생할 것 같지만, 오류가 발생하지 않고 undefined가 출력된다.
 * 이는 중간에 변수를 선언하더라도 변수가 프로그램 첫머리에 선언된 것처럼 다른 문장 앞에 생성되기 때문이다.
 * 이를 호이스팅(hoisting)이라고 한다. 
 * 단, 선언과 동시에 대입하는 코드는 끌어올리지 않는다.
 */

/**
 * const, let의 차이
 * const : 한 번 값을 할당하면 다른 값을 할당할 수 없다. 또한 초기화할 때 값을 할당하지 않으면 에러가 발생한다.
 * let : 다른 값을 할당할 수 있다.
 */

// const a = 0;
// a = 1;

// let b=0;
// b=1;

// const c;


/**
 * 데이터 타입
 * - 숫자나 문자열처럼 변수에 저장하는 데이터 종류
 * - 정적 타입 언어 : 변수에 타입이 있는 언어
 * 
 * 하지만 자바스크립트에는 변수에 타입이 없으므로 변수에 모든 타입의 데이터를 저장할 수 있다.
 */

// let pi = 3.14;
// console.log(3.14);

// pi = "원주율";
// console.log(pi);

/**
 * 변수 pi에 3.14와 "원주율", 즉 숫자와 문자열 모두 대입할 수 있다.
 * 즉, 자바스크립트에서는 같은 변수에 다양한 타입의 데이터를 대입할 수 있다. 
 * 이처럼 실행할 때 변수에 저장된 데이터 타입을 동적으로 바꿀 수 있는 언어 : 동적 타입 언어
 * 
 * 자바스크립트는 동적 타입 언어이므로 프로그램을 실행할 때 발생하는 타입 변환에 주의하여 변수에 어떤 타입의 데이터가 저장되는지 잘 확인해야 한다.
 */

/**
 * 데이터 타입의 분류
 * 1. 원시타입 : 숫자, 문자열, 논리값, 특수한 값(undefined, null), 심벌(ES2015+)
 * - 데이터를 구성하는 가장 기본적인 요소로 불변 값(값을 바꿀 수 없는 데이터)으로 정의되어 있다.
 * - 원시 값을 변수에 대입하면 변수에 그 값이 저장된다.
 * 
 * 2. 객체 타입 : 원시 타입에 속하지 않는 값
 * - 객체는 변수 여러 개가 모여서 만들어진 복합 데이터 타입.
 * - 객체 안에 저장된 값은 바꿀 수 있다.
 * - 객체는 참조 타입으로, 객체 타입의 값을 변수에 대입하면 변수에는 그 객체에 대한 참조(메모리에서의 위치 정보)가 할당된다.
 * - 배열, 함수, 정규 표현식 등
 */

/**
 * 원시 타입 추가 정리
 * - 문자열 : ' 나 ""를 붙여서 표현한다.
 * - ""는 빈 문자열
 * - 줄 바꿈 문자와 탭 문자 등은 문자열에 그대로 추가할 수 없다. 
 * - 특수문자는 이스케이프 시쿼스로 표현해야 한다.
 * '\'이런식'
 * : 이스케이프 시퀀스는 \(역슬래시) 뒤에 특정 문자를 뜻하는 기호를 표기한 형태를 가진다.
 * 
 * - 특수한 값
 * 값이 없음을 표현하는 특수한 값
 * undefined : 정의되지 않는 상태
 * -> 값을 아직 할당하지 않은 변수의 값
 * -> 없는 객체의 프로퍼티를 읽으려고 시도했을 때의 값
 * -> 없는 배열의 요소를 읽으려고 시도했을 때의 값
 * -> 아무것도 반환하지 않은 함수가 반환하는 값
 * -> 함수를 호출했을 때 전달받지 못한 인수의 값
 * 변수의 값의 undefined가 되는 것은 값을 할당하지 않은 결과
 * 
 * null : 아무것도 없음
 * 주로 프로그램에서 무언가를 검색했지만 찾지 못했을 때 아무것도 없음을 전달하기 위한 값으로 사용
 */

/**
 * 새로 추가된 데이터 타입
 * 
 * 1. 심벌 : 자기 자신을 제외한 그 어떤 값과도 다른 유일무이한 값
 */

// let sym1 = Symbol();    // Sysmol()은 호출할 때마다 새로운 값을 만든다.
// let sym2 = Symbol();

// console.log(sym1 == sym2);  //sym1 값과 sym2의 값이 다르다.

/**
 * 2. 템플릿 리터럴 
 * 표현식의 값을 문자열에 추가하거나 여러 줄의 문자열을 표현할 수 있다.
 * 템플릿 리터럴 안에는 플레이스 홀더를 넣을 수 있다. 이를 활용하여 문자열 안에 변수나 표현식의 결괏값을 삽입할 수 있다.
 */

// let now = new Date();
// console.log(`오늘은 ${now.getMonth()+1} 월 ${now.getDate()} 일입니다.`);

/**
 * 객체
 * - 이름과 값을 한 쌍으로 묶은 데이터를 여러개 모은 것
 * 프로퍼티 : 객체에 포함된 데이터 하나(이름과 값의 쌍), 이름 부분을 프로퍼티 이름 또는 키라고 부른다
 */

//  객체 리터럴로 객체 생성하기

// let card = {
//                 suit: "하트",
//                 rank : "A"
//             };
// console.log(card.suit); // 변수에 대입된 객체 안의 프로퍼티 값을 읽는 방법
// console.log(card["rank"]);

// 프로퍼티 추가와 삭제
// 없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가된다.

// card.value = 14;
// console.log(card);

// delete 연산자를 사용하면 프로퍼티를 삭제할 수 있다.
// delete card.rank;
// console.log(card);

// in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있다. 
// 프로퍼티가 객체에 포함되었을 때는 true를 반환하고, 포함되지 않았을 때는 false를 반환한다.

// console.log("suit" in card);
// console.log("color" in card);

// in 연산자가 조사하는 대상이 그 객체가 가진 프로퍼티와 그 객체가 상속받은 모든 프로퍼티
// card가 Object 객체를 상속받았기 때문에 toString 프로퍼티는 card에 있다는 결과가 나온다.
// console.log("toString" in card);

//  프로퍼티에 저장된 값의 타입이 함수면 그 프로퍼티를 메서드라고 부른다.

/**
 * 콜백 함수 : 다른 함수에 인수로 넘겨지는 함수
 * 주로 비동기, 이벤트 리스너를 사용할 때 사용한다.
 * 
 * 프로미스 : 콜백 지옥 현상을 극복할 수 있다.
 */

const condition = false;
const promise = new Promise((resolve, reject) => {
    if(condition) {
        resolve('성공');
    } else {
        reject('실패');
    }
});

promise 
    .then((message) => {
        console.log(message);   // 성공(resolve)한 경우 실행
    })
    .catch((error) => {
        console.error(error);   // 실패(reject)한 경우 실행
    })
    .finally(() => {    // 끝나고 무조건 실행
        console.log("무조건");
    });

/**
 * 프로미스 : 실행은 바로 하되, 결과값은 나중에 받는 객체
 * 결괏값은 실행이 완료된 후 then이나 catch 메서드를 통해 받는다.
 * 이것을 활용해서 콜백을 프로미스로 바꿀 수 있다.
 */

// 콜백함수
function findAndSaveUser(Users) {
    Users.findOne({}, (err, user) => {  // 첫 번째 콜백
        if(err) {
            return console.error(err);
        }
        user.name = 'sun';
        user.save((err) => {    // 두 번째 콜백
            if(err) {
                return console.error(err);
            }
            Users.findOne({gender : 'f'}, (err, user) => {  // 세 번째 콜백
                // 생략
            });
        });
    });
}


// 프로미스 사용
function findAndSaveUser(Users) {
    Users.findOne({})
        .then((user) => {
            user.name = 'sun';
            return user.save();
        })
        .then((user) => {
            return Users.findOne({gender : 'f'});
        })
        .then((user) => {
            // 생략
        })
        .catch(err => {
            console.error(err);
        }) 
}

/**
 * async/await
 * : ES2017에서 추가된 기능. 비동기 위주로 프로그래밍 할 때 도움이 된다.
 * 프로미스는 then, catch가 계속 반복되므로 복잡하다.
 * async/await 문법은 프로미스를 사용한 코드를 줄여준다.
 */

async function findAndSaveUser(Users) {
    let user = await Users.findOne({});
    user.name = 'sun';
    user = await user.save();
    user = await Users.findOne({gender : 'f'});
    //생략
}

// 함수 선언부를 async function으로 교체하고 프로미스 앞에 await를 붙인다.
// 이제 함수는 해당 프로미스가 resolve될 때까지 기다린 뒤 다음 로직으로 넘어간다.
// await User.findOne({})이 resolve 될 때까지 기다린 다음에 user 변수를 초기화하는 것.
